{
    "contents" : "#' A function for analyzing two-sample problems\n#' \n#' The \\code{rank.two.sample()} function calculates the weighted or unweighted treatment effect in\n#' a two-sample problem. In addition to \\code{\\link{rankFD}}, the user can specify the alternative\n#' and choose from a variety of different possibilities to calculate confidence intervals, see the details\n#' below. Furthermore, a Wilcoxon test is calculate with the possibility to consider shift effects.\n#' \n#' @param formula A model \\code{\\link{formula}} object. The left hand side\n#'    contains the response variable and the right hand side contains the factor\n#'    variables of interest. An interaction term must be specified.\n#' @param data A data.frame, list or environment containing the variables in \n#'    \\code{formula}. The default option is \\code{NULL}.\n#' @param conf.level A number specifying the confidence level; the default is 0.95.\n#' @param alternative Which alternative is considered? One of \"two.sided\", \"less\", \"greater\".\n#' @param rounds Value specifying the number of digits the results are rounded to.\n#' @param method specifying the method used for calculation of the confidence intervals.\n#'    One of \"logit\", \"probit\", \"normal\", \"t.app\" and \"permu\".\n#' @param plot.simci Logical, indicating whether or not confidence intervals\n#'    should be plotted\n#' @param info Logical. info = FALSE suppresses the output of additional information\n#'    concerning e.g. the interpretation of the test results.\n#' @param wilcoxon asymptotic or exact calculation of Wilcoxon test.\n#' @param shift.int Logical, indicating whether or not shift effects should be considered.\n#' @param nperm Number of permutations used, default is 10000.\n#' \n#' @references Brunner, E. and Munzel, U. (2000). The nonparametric Behrens-Fisher problem: Asymptotic\n#' theory and a small-sample approximation. Biometrical Journal 1, 17 - 21.\n#' \n#' Kaufmann, J., Werner, C., and Brunner, E. (2005). Nonparametric methods for analysing the\n#' accuracy of diagnostic tests with multiple readers. Statistical Methods in Medical Research 14, 129 - 146\n#' \n#' Pauly, M., Asendorf, T., and Konietschke, F. (2016). Permutation tests and confidence intervals for \n#' the area under the ROC-curve. Biometrical Journal, to appear.\n#' \n#' @details The confidence intervals are given for the treatment effect \\eqn{p = P(X_1 < Y_1) + \\frac{1}{2}P(X_1 = Y_1)}\n#' underlying the Wilcoxon-Mann-Whitney test including tied data. Different methods for calculation can be chosen, \n#' see Pauly et al.(2016) for the permutation approach, Brunner and Munzel (2000) for the t-approximation and\n#' Kaufmann et al.(2005) for the transformations. For plotting, the parameter plot.simci must be set to \\code{TRUE}.\n#' \n#' @examples\n#' data(Muco)\n#' Muco2 <- subset(Muco, Disease != \"OAD\")\n#' twosample <- rank.two.samples(HalfTime ~ Disease, data = Muco2, \n#'    alternative = \"greater\", method = \"probit\", wilcoxon = \"exact\", plot.simci = FALSE)\n#' \n#' @seealso \\code{\\link{rankFD}}\n#' \n#' @export\n\n\nrank.two.samples<-function (formula, data, conf.level = 0.95, \nalternative = c(\"two.sided\", \n    \"less\", \"greater\"), rounds = 3, method = c(\"logit\", \"probit\", \n    \"normal\", \"t.app\", \"permu\"), plot.simci = FALSE, info = TRUE, \nwilcoxon=c(\"asymptotic\",\"exact\"),shift.int=TRUE,\n    nperm = 10000) \n{\n    \n    alpha <- 1 - conf.level\n    if (alpha >= 1 || alpha <= 0) {\n        stop(\"The confidence level must be between 0 and 1!\")\n        if (is.null(alternative)) {\n            stop(\"Please declare the alternative! (two.sided, less, greater)\")\n        }\n    }\n\n    alternative <- match.arg(alternative)\n    method <- match.arg(method)\nwilcoxon <- match.arg(wilcoxon)\n    if (length(formula) != 3) {\n        stop(\"You can only analyse one-way layouts!\")\n    }\n    dat <- model.frame(formula, droplevels(data))\n    if (ncol(dat) != 2) {\n        stop(\"Specify one response and only one class variable in the formula\")\n    }\n    if (is.numeric(dat[, 1]) == FALSE) {\n        stop(\"Response variable must be numeric\")\n    }\n    response <- dat[, 1]\n    factorx <- as.factor(dat[, 2])\n    fl <- levels(factorx)\n    a <- nlevels(factorx)\n    if (a > 2) {\n        stop(\"You want to perform a contrast test (the factor variable has more than two levels). Please use the function mctp!\")\n    }\n    samples <- split(response, factorx)\n    n <- sapply(samples, length)\n    n1 <- n[1]\n    n2 <- n[2]\n    if (any(n == 1)) {\n        warn <- paste(\"The factor level\", fl[n == 1], \"has got only one observation!\")\n        stop(warn)\n    }\n    N <- sum(n)\n  \n    \n    rxy <- rank(c(samples[[1]], samples[[2]]))\n    rx <- rank(c(samples[[1]]))\n    ry <- rank(c(samples[[2]]))\n    pl1 <- 1/n2 * (rxy[1:n1] - rx)\n    pl2 <- 1/n1 * (rxy[(n1 + 1):N] - ry)\n    pd <- mean(pl2)\n    pd1 <- (pd == 1)\n    pd0 <- (pd == 0)\n    pd[pd1] <- 0.999\n    pd[pd0] <- 0.001\n    s1 <- var(pl1)/n1\n    s2 <- var(pl2)/n2\n    V <- N * (s1 + s2)\n    singular.bf <- (V == 0)\n    V[singular.bf] <- N/(2 * n1 * n2)\n    switch(method, normal = {\n        AsyMethod <- \"Normal - Approximation\"\n        T <- sqrt(N) * (pd - 1/2)/sqrt(V)\n  cmpid <- paste(\"p(\", fl[1], \",\", fl[2], \")\", sep = \"\")\nplotz <- 1\n        switch(alternative, two.sided = {\n            text.Output <- paste(\"True relative effect p is less or equal than 1/2\")\n            p.Value <- min(2 - 2 * pnorm(T), 2 * pnorm(T))\n            crit <- qnorm(1 - alpha/2)\n            Lower <- pd - crit/sqrt(N) * sqrt(V)\n            Upper <- pd + crit/sqrt(N) * sqrt(V)\n        }, less = {\n            text.Output <- paste(\"True relative effect p is less than 1/2\")\n            p.Value <- pnorm(T)\n            crit <- qnorm(1 - alpha)\n            Lower <- 0\n            Upper <- pd + crit/sqrt(N) * sqrt(V)\n        }, greater = {\n            text.Output <- paste(\"True relative effect p is greater than 1/2\")\n            p.Value <- 1 - pnorm(T)\n            crit <- qnorm(1 - alpha)\n            Lower <- pd - crit/sqrt(N) * sqrt(V)\n            Upper <- 1\n        })\n        data.info <- data.frame(Sample = fl, Size = n)\n        Analysis <- data.frame(Effect = cmpid, Estimator = round(pd, \n            rounds), Lower = round(Lower, rounds), Upper = round(Upper, \n            rounds), T = round(T, rounds), p.Value = round(p.Value, \n            rounds))\n        rownames(Analysis) <- 1\n    }, t.app = {\nplotz <- 1\ncmpid <- paste(\"p(\", fl[1], \",\", fl[2], \")\", sep = \"\")\n        T <- sqrt(N) * (pd - 1/2)/sqrt(V)\n        df.sw <- (s1 + s2)^2/(s1^2/(n1 - 1) + s2^2/(n2 - 1))\n        df.sw[is.nan(df.sw)] <- 1000\n        AsyMethod <- paste(\"Brunner - Munzel - T - Approx with\", \n            round(df.sw, rounds), \"DF\")\n        switch(alternative, two.sided = {\n            text.Output <- paste(\"True relative effect p is less or equal than 1/2\")\n            p.Value <- min(2 - 2 * pt(T, df = df.sw), 2 * pt(T, \n                df = df.sw))\n            crit <- qt(1 - alpha/2, df = df.sw)\n            Lower <- pd - crit/sqrt(N) * sqrt(V)\n            Upper <- pd + crit/sqrt(N) * sqrt(V)\n        }, less = {\n            text.Output <- paste(\"True relative effect p is less than 1/2\")\n            p.Value <- pt(T, df = df.sw)\n            crit <- qt(1 - alpha, df = df.sw)\n            Lower <- 0\n            Upper <- pd + crit/sqrt(N) * sqrt(V)\n        }, greater = {\n            text.Output <- paste(\"True relative effect p is greater than 1/2\")\n            p.Value <- 1 - pt(T, df = df.sw)\n            crit <- qt(1 - alpha, df = df.sw)\n            Lower <- pd - crit/sqrt(N) * sqrt(V)\n            Upper <- 1\n        })\n        data.info <- data.frame(Sample = fl, Size = n)\n        Analysis <- data.frame(Effect = cmpid, Estimator = round(pd, \n            rounds), Lower = round(Lower, rounds), Upper = round(Upper, \n            rounds), T = round(T, rounds), p.Value = round(p.Value, \n            rounds))\n        rownames(Analysis) <- 1\n        result <- list(Info = data.info, Analysis = Analysis)\n    }, logit = {\ncmpid <- paste(\"p(\", fl[1], \",\", fl[2], \")\", sep = \"\")\nplotz <- 1\n        AsyMethod <- \"Logit - Transformation\"\n        logitf <- function(p) {\n            log(p/(1 - p))\n        }\n        expit <- function(G) {\n            exp(G)/(1 + exp(G))\n        }\n        logit.pd <- logitf(pd)\n        logit.dev <- 1/(pd * (1 - pd))\n        vd.logit <- logit.dev^2 * V\n        T <- (logit.pd) * sqrt(N/vd.logit)\n        switch(alternative, two.sided = {\n            text.Output <- paste(\"True relative effect p is less or equal than 1/2\")\n            p.Value <- min(2 - 2 * pnorm(T), 2 * pnorm(T))\n            crit <- qnorm(1 - alpha/2)\n            Lower <- expit(logit.pd - crit/sqrt(N) * sqrt(vd.logit))\n            Upper <- expit(logit.pd + crit/sqrt(N) * sqrt(vd.logit))\n        }, less = {\n            text.Output <- paste(\"True relative effect p is less than 1/2\")\n            p.Value <- pnorm(T)\n            crit <- qnorm(1 - alpha)\n            Lower <- 0\n            Upper <- expit(logit.pd + crit/sqrt(N) * sqrt(vd.logit))\n        }, greater = {\n            text.Output <- paste(\"True relative effect p is greater than 1/2\")\n            p.Value <- 1 - pnorm(T)\n            crit <- qnorm(1 - alpha)\n            Lower <- expit(logit.pd - crit/sqrt(N) * sqrt(vd.logit))\n            Upper <- 1\n        })\n        data.info <- data.frame(Sample = fl, Size = n)\n        Analysis <- data.frame(Effect = cmpid, Estimator = round(pd, \n            rounds), Lower = round(Lower, rounds), Upper = round(Upper, \n            rounds), T = round(T, rounds), p.Value = round(p.Value, \n            rounds))\n        rownames(Analysis) <- 1\n        result <- list(Info = data.info, Analysis = Analysis)\n    }, \nprobit = {\ncmpid <- paste(\"p(\", fl[1], \",\", fl[2], \")\", sep = \"\")\nplotz <- 1\n        AsyMethod <- \"Probit - Transformation\"\n        probit.pd <- qnorm(pd)\n        probit.dev <- sqrt(2 * pi)/(exp(-0.5 * qnorm(pd) * qnorm(pd)))\n        vd.probit <- probit.dev^2 * V\n        T <- (probit.pd) * sqrt(N/vd.probit)\n        switch(alternative, two.sided = {\n            text.Output <- paste(\"True relative effect p is less or equal than 1/2\")\n            p.Value <- min(2 - 2 * pnorm(T), 2 * pnorm(T))\n            crit <- qnorm(1 - alpha/2)\n            Lower <- pnorm(probit.pd - crit/sqrt(N) * sqrt(vd.probit))\n            Upper <- pnorm(probit.pd + crit/sqrt(N) * sqrt(vd.probit))\n        }, less = {\n            text.Output <- paste(\"True relative effect p is less than 1/2\")\n            p.Value <- pnorm(T)\n            crit <- qnorm(1 - alpha)\n            Lower <- 0\n            Upper <- pnorm(probit.pd + crit/sqrt(N) * sqrt(vd.probit))\n        }, greater = {\n            text.Output <- paste(\"True relative effect p is greater than 1/2\")\n            p.Value <- 1 - pnorm(T)\n            crit <- qnorm(1 - alpha)\n            Lower <- pnorm(probit.pd - crit/sqrt(N) * sqrt(vd.probit))\n            Upper <- 1\n        })\n        data.info <- data.frame(Sample = fl, Size = n)\n        Analysis <- data.frame(Effect = cmpid, Estimator = round(pd, \n            rounds), Lower = round(Lower, rounds), Upper = round(Upper, \n            rounds), T = round(T, rounds), p.Value = round(p.Value, \n            rounds))\n        rownames(Analysis) <- 1\n        result <- list(Info = data.info, Analysis = Analysis)\n    }, permu = {\nplotz <- 3\ncmpid <- c(\"id\", \"logit\", \"probit\")   \nTperm=Tlogitperm=Tprobitperm=c()\n\nausgang = BMstat(samples[[1]],samples[[2]],n1,n2)\nfor(h in 1:nperm){\nrespperm=sample(response)\nphelp=BMstat(respperm[1:n1],respperm[(n1+1):N],n1,n2)\nTperm[h] = phelp$T\nTlogitperm[h] = phelp$Logit\nTprobitperm[h] = phelp$Probit\n}\np.PERM1 = mean(ausgang$T >= Tperm)\np.PERMLogit1 = mean(ausgang$Logit >= Tlogitperm)\np.PERMProbit1 = mean(ausgang$Probit >= Tprobitperm)\nc1 = quantile(Tperm,(1-conf.level)/2)\nc2 = quantile(Tperm,1-(1-conf.level)/2)\n\nc1LOGIT = quantile(Tlogitperm,(1-conf.level)/2)\nc2LOGIT = quantile(Tlogitperm,1-(1-conf.level)/2)\nc1PROBIT = quantile(Tprobitperm,(1-conf.level)/2)\nc2PROBIT = quantile(Tprobitperm,1-(1-conf.level)/2)\nc1lower = quantile(Tperm,(1-conf.level))\nc2upper = quantile(Tperm,1-(1-conf.level))\nc1LOGITlower = quantile(Tlogitperm,(1-conf.level))\nc2LOGITupper = quantile(Tlogitperm,1-(1-conf.level))\nc1PROBITlower = quantile(Tprobitperm,(1-conf.level))\nc2PROBITupper = quantile(Tprobitperm,1-(1-conf.level))\n  \n\n        switch(alternative, two.sided = {\n            text.Output <- paste(\"True relative effect p is less or equal than 1/2\")\n            p.PERM <- min(2 - 2 * p.PERM1, 2 * p.PERM1)\n            p.LOGIT <- min(2 - 2 * p.PERMLogit1, 2 * p.PERMLogit1)\n            p.PROBIT <- min(2 - 2 * p.PERMProbit1, 2 *p.PERMProbit1)\n        UntenRS <- pd - sqrt(ausgang$sdx/N) * c2\n        ObenRS <- pd - sqrt(ausgang$sdx/N) * c1\n\n        ULogitRS <- logit(pd) - ausgang$slogit/sqrt(N) * c2LOGIT\n        OLogitRS <- logit(pd) - ausgang$slogit/sqrt(N) * c1LOGIT\n        UntenLogitRS <- expit(ULogitRS)\n        ObenLogitRS <- expit(OLogitRS)\n        UProbitRS <- qnorm(pd) - ausgang$sprobit/sqrt(N) * c2PROBIT\n        OProbitRS <- qnorm(pd) - ausgang$sprobit/sqrt(N) * c1PROBIT\n\n        UntenProbitRS <- pnorm(UProbitRS)\n        ObenProbitRS <- pnorm(OProbitRS)\n        Statistic <- round(c(ausgang$T, ausgang$Logit, ausgang$Probit), rounds)\n        Estimator <- round(rep(pd, 3), rounds)\n        Lower <- round(c(UntenRS, UntenLogitRS, UntenProbitRS), \n            rounds)\n        Upper <- round(c(ObenRS, ObenLogitRS, ObenProbitRS), \n            rounds)\n        p.value <- c(p.PERM, p.LOGIT, p.PROBIT)\n\t\tAnalysis <- data.frame(Estimator, Statistic, Lower, \n            Upper, p.value, row.names = c(\"id\", \"logit\", \"probit\"))\n        }, less = {\n            text.Output <- paste(\"True relative effect p is less than 1/2\")\n            p.PERM = p.PERM1\n            p.LOGIT <- p.PERMLogit1\n            p.PROBIT <- p.PERMProbit1\n        UntenRS <- 0\n        ObenRS <- pd - sqrt(ausgang$sdx/N) * c1lower\n        OLogitRS <- logit(pd) - ausgang$slogit/sqrt(N) * c1LOGITlower\n        UntenLogitRS <-0\n        ObenLogitRS <- expit(OLogitRS)\n        OProbitRS <- qnorm(pd) - ausgang$sprobit/sqrt(N) * c1PROBITlower\n\n        UntenProbitRS <- 0\n        ObenProbitRS <- pnorm(OProbitRS)\n        Statistic <- round(c(ausgang$T, ausgang$Logit, ausgang$Probit), rounds)\n        Estimator <- round(rep(pd, 3), rounds)\n        Lower <- round(c(UntenRS, UntenLogitRS, UntenProbitRS), \n            rounds)\n        Upper <- round(c(ObenRS, ObenLogitRS, ObenProbitRS), \n            rounds)\n        p.value <- c(p.PERM, p.LOGIT, p.PROBIT)\n\t\tAnalysis <- data.frame(Estimator, Statistic, Lower, \n            Upper, p.value, row.names = c(\"id\", \"logit\", \"probit\"))\n\n        }, greater = {\n            text.Output <- paste(\"True relative effect p is greater than 1/2\")\n            p.PERM = 1-p.PERM1\n            p.LOGIT <-1- p.PERMLogit1\n            p.PROBIT <- 1-p.PERMProbit1\n        UntenRS <- pd - sqrt(ausgang$sdx/N) * c2upper\n        ObenRS <- 1\n\t  ULogitRS <- logit(pd) - ausgang$slogit/sqrt(N) * c2LOGITupper\n        UntenLogitRS <-expit(ULogitRS)\n        ObenLogitRS <- 1\n      \n\n        UProbitRS <- qnorm(pd) - ausgang$sprobit/sqrt(N) * c2PROBITupper\n        UntenProbitRS <- pnorm(UProbitRS)\n\t  ObenProbitRS <- 1\n        Statistic <- round(c(ausgang$T, ausgang$Logit, ausgang$Probit), rounds)\n        Estimator <- round(rep(pd, 3), rounds)\n        Lower <- round(c(UntenRS, UntenLogitRS, UntenProbitRS), \n            rounds)\n        Upper <- round(c(ObenRS, ObenLogitRS, ObenProbitRS), \n            rounds)\n        p.value <- round(c(p.PERM, p.LOGIT, p.PROBIT), rounds)\n\t\tAnalysis <- data.frame(Link=cmpid, Estimator, Statistic, Lower, \n            Upper, p.value, row.names = c(\"id\",\"logit\",\"probit\"))\n\n\n        })\n\n        \n        AsyMethod <- \"Studentized Permutation Test (+ delta-method)\"\n        \n        data.info <- data.frame(Sample = fl, Size = n)\n       result <- list(Info = data.info, Analysis = Analysis)\n    })\n\n\n#------------SHIFT EFFECTS--------------------------------#\nHL.help=expand.grid(samples[[1]],samples[[2]])\nHL=median(HL.help[,2]-HL.help[,1])\nswitch(wilcoxon,asymptotic={\nWilcox = wilcox_test(response~factorx,distribution=\"asymptotic\",\nalternative=alternative,\nconf.int=TRUE,conf.level=(1 - alpha))\np.wilcox=pvalue(Wilcox)\nZ.wilcox=statistic(Wilcox)\nif(shift.int==TRUE){\nshiftint=sort(-1*c(confint(Wilcox)$conf.int))\nLower.Shift=shiftint[1]\nUpper.Shift=shiftint[2]\n}\n},\nexact={\nWilcox = wilcox_test(response~factorx,distribution=\"exact\",\nalternative=alternative,conf.int=TRUE,conf.level=(1 - alpha))\np.wilcox=pvalue(Wilcox)\nZ.wilcox=sum(ry)\nif(shift.int==TRUE){\nshiftint=sort(-1*c(confint(Wilcox)$conf.int))\nLower.Shift=shiftint[1]\nUpper.Shift=shiftint[2]\n}\n})\n\n\n\n\nif(shift.int==FALSE){\nLower.Shift = NA\nUpper.Shift= NA\nHL = NA\n}\ncmpidWilcoxon1 <- paste(\"p(\", fl[1], \",\", fl[2], \")\", sep = \"\")\ncmpidWilcoxon2 <- paste(\"delta\",\"(\",fl[2], \"-\", fl[1], \")\", sep = \"\")\n\n\nWilcoxon.Test=data.frame(Effect = cmpidWilcoxon1, Estimator=pd,\nStatistic=Z.wilcox,p.Value=p.wilcox,Shift=cmpidWilcoxon2, Hodges.Lehmann=HL,Lower=Lower.Shift,Upper=Upper.Shift)\n result <- list(Info = data.info, Analysis = Analysis, Wilcoxon=Wilcoxon.Test)\n\n    if (plot.simci == TRUE) {\n\n        text.Ci <- paste((1 - alpha) * 100, \"%\", \"Confidence Interval for p\")\n        Lowerp <- \"|\"\n\n        plot(rep(pd, plotz), 1:plotz, xlim = c(0, 1), pch = 15, \n            axes = FALSE, xlab = \"\", ylab = \"\")\n        points(Lower, 1:plotz, pch = Lowerp, font = 2, cex = 2)\n        points(Upper, 1:plotz, pch = Lowerp, font = 2, cex = 2)\n        abline(v = 0.5, lty = 3, lwd = 2)\n        for (ss in 1:plotz) {\n            polygon(x = c(Lower[ss], Upper[ss]), y = c(ss, ss), \n                lwd = 2)\n        }\n        axis(1, at = seq(0, 1, 0.1))\n        axis(2, at = 1:plotz, labels = cmpid, font = 2)\n        box()\n        title(main = c(text.Ci, paste(\"Method:\", AsyMethod)))\n    }\n    if (info == TRUE) {\n        cat(\"\\n\", \"#------Nonparametric Test Procedures and Confidence Intervals for relative  effects-----#\", \n            \"\\n\", \"\\n\", \"-\", \"Alternative Hypothesis: \", text.Output, \n            \"\\n\", \"-\", \"Confidence level:\", (1 - alpha) * 100, \n            \"%\", \"\\n\", \"-\", \"Method\", \"=\", AsyMethod, \"\\n\", \"\\n\", \n            \"#---------------------------Interpretation----------------------------------#\", \n            \"\\n\", \"p(a,b)\", \">\", \"1/2\", \":\", \"b tends to be larger than a\", \n            \"\\n\", \"#---------------------------------------------------------------------------#\", \n            \"\\n\", \"\\n\")\n    }\n    #result$input <- input.list\n    #result$text.Output <- text.Output\n    #result$cmpid <- cmpid\n    #result$AsyMethod <- AsyMethod\n    #class(result) <- \"ranktwosamples\"\n    return(result)\n}\n\n\n",
    "created" : 1461739745005.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "802242423",
    "id" : "14364CD1",
    "lastKnownWriteTime" : 1467116629,
    "path" : "~/Dropbox/rankFD/rankFD/R/ranktwosamples.R",
    "project_path" : "R/ranktwosamples.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}